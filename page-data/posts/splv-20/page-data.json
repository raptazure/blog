{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/splv-20/","result":{"data":{"site":{"siteMetadata":{"title":"Raptazure","description":"魔法の森","author":{"name":"raptazure","twitter":"https://twitter.com/raptazure","github":"https://github.com/raptazure"}}},"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SPLV Idris\",\n  \"date\": \"2021-01-22T00:00:00.000Z\",\n  \"tags\": [\"type theory\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"The implementation of Idris 2\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Understand how a dependently typed language works, primarily type checking and elaboration.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type checking is where you have the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Core\"), \" representation. It is completely explicit and we will check that the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Core\"), \" representation is well typed by the type that you claimed it has. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elaboration is a higher-level step. It is where you take something that is more like the user level code and elaborate it to put all of the concrete precise type information that is needed for the mechine to type check. What Idris 2 does is it will take a few steps of elabration and it will eventually end up at the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Core\"), \" representation and at that point, we have a very small core language. It is then possible to feed that again to a type checker which is just not very clever and just knows about the core typing rules to ensure what is produced as a process of elaboration is valid.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The implementation of Idris 2 Understand how a dependently typed language works, primarily type checking and elaboration. Type checking is…","fields":{"lang":"zh-Hans"},"frontmatter":{"title":"SPLV Idris","date":"2021-01-22","tags":["type theory"]}}},"pageContext":{"slug":"/posts/splv-20/"}},"staticQueryHashes":["2345487092"]}