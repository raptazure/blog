{"componentChunkName":"component---src-templates-journal-tsx","path":"/journal/2021-02-06/","result":{"data":{"site":{"siteMetadata":{"title":"Raptazure","description":"Meditation","author":{"name":"raptazure","twitter":"https://twitter.com/raptazure","github":"https://github.com/raptazure"}}},"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"journal\",\n  \"title\": \"编程语言杂谈\",\n  \"date\": \"2021-02-06T00:00:00.000Z\",\n  \"tags\": [\"journal\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Knowledge\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"qx \\u66F0\\uFF1Aterm level \\u7684 operator \\u90FD\\u53EB !\\uFF0Csemantics level \\u7684\\u90FD\\u662F >>\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tiz \\u66F0\\uFF1Afirst class modules are dependent records. ref: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/clarus/coq-of-ocaml\"\n  }, \"coq-of-ocaml\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u4E0D\\u8FC7\\uFF0CReScript \\u4F5C\\u8005\\u6307\\u7684\\u5E94\\u8BE5\\u662F\\u7528 GADT \\u6A21\\u62DF dependent types\\uFF0C\\u5C31\\u50CF Haskell \\u7528 Singleton \\u6A21\\u62DF\\u7684\\u90A3\\u79CD\\u611F\\u89C9\\uFF0C\\u679C\\u7136\\u8FD8\\u662F\\u89C9\\u5F97\\u4E0D\\u7B97\\u6709\\u652F\\u6301 = =\")), mdx(\"h2\", null, \"Thoughts\"), mdx(\"p\", null, \"\\u770B\\u4E86\\u770B Y Combinator \\u4E0A\\u5173\\u4E8E Haskell Motto \\u7684\\u89E3\\u91CA\\uFF0C\\u518D\\u52A0\\u4E0A\\u5BF9 lazy evaluation \\u4EE5\\u53CA purely functional \\u7684\\u8FC1\\u79FB\\u7406\\u89E3\\uFF0C\\u8D8A\\u6765\\u8D8A\\u89C9\\u5F97\\u8FD9\\u8BED\\u8A00\\u548C\\u6211\\u7684\\u6027\\u683C\\u6709\\u4E9B\\u50CF\\u554A\\u2026 \\u53EF\\u80FD\\u8FD9\\u4E5F\\u7B97\\u662F\\u7F18\\u5206\\u5427\\uFF0C\\u6BD5\\u7ADF\\u5F53\\u521D\\u914D\\u73AF\\u5883\\u51FA\\u5947\\u7684\\u987A\\u5229\\uFF0C\\u5B66\\u8D77\\u6765\\u4E5F\\u8FD8\\u7B97\\u86EE\\u5FEB\\u7684\\uFF0C\\u5C31\\u50CF\\u300C\\u5C5E\\u6027\\u76F8\\u5408\\u300D\\u7684\\u611F\\u89C9\\u4E00\\u6837\\u3002\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The Haskell motto is avoid success at all costs, usually clarified to \\u300Cavoid success at all costs\\u300D. In other words, success (popularity, widespread use in industry, teaching, etc.) is not a justification for \\u300Ccosts\\u300D such as limiting expressiveness, making things less safe, restricting research possibilities, etc. Haskell would prefer to be powerful, safe, efficient, obscure and niche; rather than popular, industry-standard, widely-known, highly compatible, unsafe, insecure, inefficient and restricted (besides, we have loads of languages of this sort!).\")), mdx(\"p\", null, \"\\u8FD1\\u671F\\u4E5F\\u662F\\u57FA\\u672C\\u90FD\\u5728\\u5199 Haskell \\u5BB6\\u7684\\u8FD9\\u4E9B\\u8BED\\u8A00\\uFF0C\\u6BD4\\u5982 PureScript \\u5440\\uFF0CIdris \\u5440\\uFF0CAgda \\u5440\\uFF0C\\u5F53\\u7136\\u8FD8\\u6709 Haskell\\u2026 \\u9664\\u4E86\\u505A\\u4E00\\u4E9B low level / speed critical \\u6216\\u8005\\u4E0D\\u9700\\u8981\\u5F88\\u591A abstraction \\u800C\\u662F\\u66F4 detail oriented / imperative style \\u7684\\u6D3B\\u4F1A\\u7528 Rust\\uFF0C\\u4E0D\\u8FC7\\u65E2\\u7136\\u53EF\\u4EE5\\u628A\\u5C0F\\u9508\\u8783\\u87F9\\u53EB\\u505A Mozilla ML with typeclasses \\u561B\\uFF0C\\u6240\\u4EE5\\u4E5F\\u7B97\\u662F\\u4EB2\\u621A\\uFF0C\\u800C\\u4E14\\u8FD9\\u4FE9\\u793E\\u533A\\u7684\\u4EA4\\u4E92\\u770B\\u8D77\\u6765\\u4E5F\\u86EE\\u6709\\u8DA3\\u7684\\u3002\"), mdx(\"p\", null, \"\\u5982\\u679C\\u975E\\u8981\\u586B\\u4E00\\u4E2A { ?language } programmer \\u7684\\u8BDD\\uFF0C\\u6211\\u60F3\\u81EA\\u5DF1\\u4F1A\\u9009 Haskell \\u5427\\u3002\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Knowledge qx 曰：term level 的 operator 都叫 !，semantics level 的都是 >> tiz 曰：first class modules are dependent records. ref:  coq-of-ocaml…","fields":{"lang":"zh-Hans"},"frontmatter":{"title":"编程语言杂谈","date":"2021-02-06","tags":["journal"]}}},"pageContext":{"slug":"/journal/2021-02-06/"}},"staticQueryHashes":["2345487092"]}